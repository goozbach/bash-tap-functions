#!/bin/bash 

version='1.0'
	
_plan_set=0
_no_plan=0
_skip_all=0
_test_died=0
_expected_tests=0 
_executed_tests=0 
_failed_tests=0
_todo=''


set -u
trap _exit EXIT

	
plan_no_plan(){
	[ $_plan_set != 0 ] && "You tried to plan twice!"

	_plan_set=1
	_no_plan=1

	return 1
}


plan_skip_all(){
	local reason=$1

	[ $_plan_set != 0 ] && _die "You tried to plan twice!"

	_print_plan 0 "Skip $reason"

	_skip_all=1
	_plan_set=1
	_exit 0

	return 0
}


plan_tests(){
	local tests=$1

	[ $_plan_set != 0 ] && _die "You tried to plan twice!"
	[ $tests == 0 ] && _die "You said to run 0 tests!  You've got to run something."

	_print_plan $tests
	_expected_tests=$tests
	_plan_set=1

	return $tests
}


_print_plan(){
	local tests=$1
	local directive=${2:-''}

	echo -n "1..$tests"
	[ -n "$directive" ] && echo -n " # $directive"
	echo
}


pass(){
	local name=$1
	ok 0 $name
}


fail(){
	local name=$1
	ok 1 $name
}


# This is the workhorse method that actually
# prints the tests result.
ok(){
	local result=$1
	local name=$2 

	[ $_plan_set == 0 ] && _die "You tried to run a test without a plan!  Gotta have a plan."

	_executed_tests=$(($_executed_tests + 1))

	#if (name != null) {
	#	if (name.matches("[\\d\\s]+")){
	#		diag("    You named your test '" + name 
	#			+ "'.  You shouldn't use numbers for your test names.") ;
	#		diag("    Very confusing.") ;
	#	}
	#}

	if [ "$result" != 0 ] ; then
		echo -n "not "
		_failed_tests=$(($_failed_tests + 1))
	fi
	echo -n "ok $_executed_tests"

	#if (name != null) {
	#	out.print(" - ") ;
	#	out.print(name.replaceAll("#", "\\\\#")) ;
	#}

	#if (_todo != null){
	#	out.print(" # TODO " + +todo) ;
	#	if (! result){
	#		failed_tests-- ;
	#	}
	#}

	echo
	#if (! result){
	#	Throwable t = new Throwable() ; 
	#	StackTraceElement stack[] = t.getStackTrace() ;
	#	String file = null ;
	#	String clas = null ;
	#	String func = null ;
	#	int line = 0 ;

	#	try {
	#		for (int i = 0 ; i < stack.length ; i++){
	#			Class c = Class.forName(stack[i].getClassName()) ;
	#			if (! JTap.class.isAssignableFrom(c)){
	#				// We are outside a JTap object, so this is probably the callpoint
	#				file = stack[i].getFileName() ;
	#				clas = c.getName() ;
	#				func = stack[i].getMethodName() ;
	#				line = stack[i].getLineNumber() ;
	#				break ;
	#			}
	#		}
	#	}
	#	catch (Exception e){
	#		e.printStackTrace() ;
	#	}

	#	if (name != null){		
	#		diag("  Failed " + (_todo == null ? "" : "(TODO) ") + "test '" + name + "'") ;
	#		diag("  in " + file + ":" + func + "() at line " + line + ".") ;
	#	}
	#	else {
	#		diag("  Failed " + (_todo == null ? "" : "(TODO) ") + "test in " + file + ":" + func + "() at line " + line + ".") ;
	#	}
	#}

	return $result
}


_equals(){
	local result=$1
	local expected=$2

	if [ "$result" = "$expected" ] ; then
		return 0
	else 
		return 1
	fi
}


_matches(){
	local result=$1
	local pattern=$2

	if [ -z "$result" -o -z "$pattern" ] ; then
		return 1
	elif [[ "$result" =~ "$pattern" ]] ; then
		return 0
	else 
		return 1
	fi
}


_is_diag(){
	local result=$1
	local expected=$2

	diag "         got: '$result'" 
	diag "    expected: '$expected'"
}


is(){
	local result=$1
	local expected=$2
	local name=${3:-''}

	_equals $result $expected
	[ $? = 0 ]
	ok $? name
	local r=$?
	[ $r != 0 ] && _is_diag $result $expected
	return $r 
}


isnt(){
	local result=$1
	local expected=$2
	local name=${3:-''}

	_equals $result $expected
	[ $? = 0 ]
	ok $? name
	local r=$?
	[ $r != 0 ] && _is_diag $result $expected
	return $r 
}


like(){
	local result=$1
	local pattern=$2
	local name=${3:-''}

	_matches $result $pattern
	[ $? = 0 ]
	ok $? name
	local r=$?
	[ $r != 0 ] && diag "    '$result' doesn't match '$pattern'"
	return $r
}


unlike(){
	local result=$1
	local pattern=$2
	local name=${3:-''}

	_matches $result $pattern
	[ $? != 0 ]
	ok $? name
	local r=$?
	[ "$r" != 0 ] && diag "    '$result' matches '$pattern'"
	return $r
}


skip(){
	local reason=$1
	local n=${2:-1}

	local i=
	for (( i=0 ; i<$n ; i++ )) ; do
		_executed_tests=$(($_executed_tests + 1))
		echo "ok $_executed_tests # skip $reason" 
	done
}


todo_start(){
	local reason=$1

	_todo=$reason
}


todo_end(){
	_todo=
}


# TODO: Support multiline messages
diag(){
	local msg=$1

	if [ -n "$msg" ] ; then
		echo "# $msg"
	fi
	
	return 1
}

	
_die(){
	local reason=$1

	echo $reason >&2
	_test_died=1
	_exit 255
}


BAIL_OUT(){
	local reason=$1

	echo "Bail out! $reason" >&2
	_exit 255
}


_cleanup(){
	local rc=0

	if [ $_plan_set = 0 ] ; then
		diag "Looks like your test died before it could output anything."
		return $rc
	fi

	if [ $_test_died != 0 ] ; then
		diag "Looks like your test died just after $_executed_tests."
		return $rc
	fi

	if [ $_skip_all = 0 -a $_no_plan != 0 ] ; then
		_print_plan $_executed_tests
	fi

	local s=
	if [ $_no_plan = 0 -a $_expected_tests -lt $_executed_tests ] ; then
		s= ; (( $_expected_tests > 1 )) && s=s
		local extra=$(($_executed_tests - $_expected_tests))
		diag "Looks like you planned $_expected_tests test$s but ran $extra extra."
		rc=-1 ;
	fi

	if [ $_no_plan = 0 -a $_expected_tests -gt $_executed_tests ] ; then
		s= ; (( $_expected_tests > 1 )) && s=s
		diag "Looks like you planned $_expected_tests test$s but only ran $_executed_tests."
	fi

	if (( $_failed_tests > 0 )) ; then
		s= ; (( $_failed_tests > 1 )) && s=s
		diag "Looks like you failed $_failed_tests test$s of $_executed_tests."
	fi

	return $rc
}


_exit_status(){
	if [ $_no_plan != 0 -a $_plan_set = 0 ] ; then
		return $_failed_tests
	fi

	if (( $_expected_tests < $_executed_tests )) ; then
		return $(($_executed_tests - $_expected_tests))
	fi

	return $(($_failed_tests + ($_expected_tests - $_executed_tests)))
}


_exit(){
	local rc=${1:-''}
	if [ -z "$rc" ] ; then
		_exit_status
		rc=$?
	fi

	_cleanup
	local alt_rc=$?
	[ $alt_rc != 0 ] && rc=$alt_rc
	trap - EXIT
	exit $rc
}

